#!/usr/bin/env bash

VERSION="0.0.1"

# Config values
WOFI_PASS_DEBUG="${WOFI_PASS_DEBUG:-0}"
WOFI_PASS_AUTOTYPE="${WOFI_PASS_AUTOTYPE:-":username :tab :password :enter"}"
WOFI_PASS_HOTKEY_COPY="${WOFI_PASS_HOTKEY_COPY:-"Alt-w"}"
WOFI_PASS_HOTKEY_COPY_RET=10
WOFI_PASS_DELAY=${WOFI_PASS_DELAY:-2}
WOFI_PASS_AUTO_ENTER="${WOFI_PASS_AUTO_ENTER:-"false"}"
WOFI_PASS_ARGS=("--dmenu" "--parse-search")
WOFI_PASS_HIDE_FIELDS=("path")
WOFI_PASS_CASE_INSENSITIVE=1

FLAG_HELP=0
FLAG_VERSION=0
FLAG_HOTKEYS_SUPPORTED=1

FIELD_OTP_TAG="<<--OTP-->>"

SEARCH_PATTERN=""
declare -A ENTRY_CACHE

debug_log() {
    if [[ "$WOFI_PASS_DEBUG" -eq 1 ]]; then
        echo "DEBUG: [${FUNCNAME[1]}] $*" >&2
    fi
}

exit_on_help_or_version() {
    if [[ "${FLAG_HELP}" -eq 1 ]]; then
        usage >&2
        exit 0
    elif [[ "${FLAG_VERSION}" -eq 1  ]]; then
        echo "${VERSION}" >&2
        exit 0
    fi
}

usage() {
    cat <<EOF
    Usage:
    wofi-pass [options] [match]

    Options:
        -h, --help        show this help message
        -v, --version     show version
        -k, --nohotkey    Disable hotkey support. By default hotkeys are supported.

    wofi-pass version ${VERSION}
EOF
}

arguments_parse() {
    OPTS="$(getopt --options hvk --longoptions help,version,nohotkey -n 'wofi-pass' -- "${@}")"
    eval set -- "${OPTS}"
    while true; do
        case "${1}" in
            -h | --help) FLAG_HELP=1; shift;;
            -v | --version) FLAG_VERSION=1; shift;;
            -k | --nohotkey) FLAG_HOTKEYS_SUPPORTED=0; shift;;
            --) shift; break;;
            *) break;;
      esac
    done
    SEARCH_PATTERN="$*"
}

config_file_get () {
    local -r config_base_dir="${XDG_CONFIG_HOME:-"${HOME}/.config"}"

    config_files=("${WOFI_PASS_CONFIG:-""}"
                  "${config_base_dir}/wofi-pass/config"
                  "/etc/wofi-pass.conf")

    for config in "${config_files[@]}"; do
        if [[ -n "${config}" && -f "${config}" ]]; then
            printf "%s" "${config}"
            return
        fi
    done
}

config_file_load () {
    config_file="$(config_file_get)"
    if [[ -n "${config_file}" ]]; then
        # shellcheck source=/dev/null
        source "${config_file}"
    fi
}

_trim() {
    local var
    var="${*}"

    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"

    printf '%s' "${var}"
}

fields_parse() {
    local -r passname="${1}"
    local -a entries
    # local -A ENTRY_CACHE
    local index entry key value

    mapfile -t entries < <(pass show "${passname}")

    index=0
    for entry in "${entries[@]}"; do
        if [[ "$index" -eq 0 ]] && [[ "$entry" != *:* ]]; then
            ENTRY_CACHE["password"]="$entry"
            debug_log "Password at index[$index]: 'ENTRY_CACHE[password]=$entry'"
        fi

        if [[ "$entry" == *": "* ]]; then
            key=$(_trim "${entry%%: *}")
            value=$(_trim "${entry#*: }")
            [[ -n "$value" ]] && ENTRY_CACHE["$key"]="$value"

            if [[ "${key}" == "password" ]]; then
                debug_log "Overriding ${key}: '${value}'"
            fi

        elif [[ "$entry" == *"otpauth://"* ]]; then
            ENTRY_CACHE["${FIELD_OTP_TAG}"]="$entry"
            debug_log "OTP at index[$index]: '${FIELD_OTP_TAG}=$entry'"
        else
            debug_log "Invalid key or value at index[$index]: '$entry'"
        fi

        ((index++))
    done

    ENTRY_CACHE["path"]="${passname}"

    if [[ -z "${ENTRY_CACHE[username]+x}" ]]; then
        ENTRY_CACHE["username"]=$(basename "$passname")
        debug_log "Not found ENTRY_CACHE[username]: '${ENTRY_CACHE["username"]}' set from filename"
    fi
}

field_get() {
    local field lines
    local -a wofi_args
    local -A entry_cache skipped_keys

    wofi_args+=("${WOFI_PASS_ARGS[@]}")

    if [[ "${FLAG_HOTKEYS_SUPPORTED}" -eq 1 ]]; then
        [[ -n "${WOFI_PASS_HOTKEY_COPY}" ]] && wofi_args+=("--define" "key_custom_0=${WOFI_PASS_HOTKEY_COPY}")
    fi

    if [[ ! -v ENTRY_CACHE["autotype"] ]]; then
        ENTRY_CACHE["autotype"]="${WOFI_PASS_AUTOTYPE}"
    fi

    for item in "${WOFI_PASS_HIDE_FIELDS[@]}"; do
        skipped_keys["$item"]=""
    done

    for item in "${!ENTRY_CACHE[@]}"; do
        [[ ! -v skipped_keys[$item] ]] && entry_cache["$item"]="${ENTRY_CACHE[$item]}"
    done

    lines="${#entry_cache[@]}"
    ((lines++))

    if [[ "${lines}" -le 13 ]];then
        wofi_args+=("--lines=${lines}")
    fi

    field="$(printf '%s\n' "${!entry_cache[@]}" | wofi "${wofi_args[@]}")"
    # field="$(printf '%s\n' "${!ENTRY_CACHE[@]}" | wofi "${wofi_args[@]}")"
    wofi_ret=${?}

    debug_log "wofi_selected: ${field}"
    debug_log "wofi_args: ${wofi_args[*]}"
    debug_log "wofi_ret: ${wofi_ret}"

    printf "%s" "${field}"
    return ${wofi_ret}
}

field_output() {
    local -r field="${1}"
    local -r hotkey="${2:-0}"
    local cmd_output

    debug_log "FIELD: ${field}"
    debug_log "HOTKEY: ${hotkey}"

    if [[ "${hotkey}" -eq 0 ]]; then
        cmd_output=("wtype")
    elif [[ "${hotkey}" -eq 10 ]]; then
        cmd_output=("wl-copy")
    fi

    if [[ "${field}" == "autotype" ]]; then
        autotype_output
    elif [[ "${field}" == "${FIELD_OTP_TAG}" ]]; then
        cmd_output+=("$(pass otp "${ENTRY_CACHE["path"]}" | head -n1)")
        "${cmd_output[@]}"
    else
        "${cmd_output[@]}" "${ENTRY_CACHE["${field}"]}"
    fi
}

autotype_output() {
    local -a wtype_args

    for word in ${ENTRY_CACHE["autotype"]}; do
        case "${word}" in
            ":tab") wtype_args+=("-k" "Tab");;
            ":space") wtype_args+=("-k" "space");;
            ":enter") wtype_args+=("-k" "Return");;
            ":delay") wtype_args+=("-s" "$((WOFI_PASS_DELAY * 1000))");;
            ":otp") wtype_args+=("$(pass otp "${ENTRY_CACHE["path"]}" | head -n1)");;
            ":password" | "pass") wtype_args+=("${ENTRY_CACHE["password"]}");;
            ":username" | "user" | "uname") wtype_args+=("${ENTRY_CACHE["username"]}");;
            ":path") wtype_args+=("${ENTRY_CACHE["path"]}");;
            *) wtype_args+=("${ENTRY_CACHE["${word}"]}")
        esac
    done

    wtype "${wtype_args[@]}"
}

passname_select() {
    local -r pass_dir="${PASSWORD_STORE_DIR}"
    local all_files password_files passname
    local wofi_args=()

    wofi_args+=("${WOFI_PASS_ARGS[@]}")
    all_files="$(find "${pass_dir}" -name "*.gpg" \
                 | sed "s|^${pass_dir}/\(.*\)\.gpg$|\1|" )"

    if [[ -n "${SEARCH_PATTERN}" ]]; then
        password_files="$(printf '%s\n' "${all_files}" \
            | grep -iF "${SEARCH_PATTERN}" \
            | sort)"

        password_files_lines=$(echo "${password_files}" | wc -l)
        ((password_files_lines++))

        if [[ "${password_files_lines}" -le 13 ]];then
            wofi_args+=("--lines=${password_files_lines}")
        fi

    else
        password_files="$(printf '%s\n' "${all_files}" | sort)"
    fi

    readonly password_files

    if [[ "${WOFI_PASS_CASE_INSENSITIVE}" -eq 1 ]]; then
        wofi_args+=("--insensitive")
    fi

    passname="$(printf '%s\n' "${password_files}" | wofi "${wofi_args[@]}")"

    debug_log "wofi_selected: ${passname}"
    debug_log "wofi_args: ${wofi_args[*]}"

    printf "%s" "${passname}"
}

main() {
    local passname field hotkey ret

    config_file_load
    arguments_parse "${@}"
    exit_on_help_or_version

    passname="$(passname_select)"
    [[ -n "${passname}" ]] || exit 1

    fields_parse "${passname}"

    ret=0
    field=$(field_get) || ret="${?}"

    if [[ "${ret}" -eq 0 ]] || [[ "${ret}" -eq "${WOFI_PASS_HOTKEY_COPY_RET}" ]]; then
        hotkey="${ret}"
    else
        exit 1
    fi

    field_output "${field}" "${hotkey}"

    if [[ "$WOFI_PASS_DEBUG" -eq 1 ]]; then
        debug_log "SEARCH_PATTERN: '${SEARCH_PATTERN}'"
        debug_log "Selected: '${passname}'"
        debug_log "<-= ENTRY_CACHE[@] =->"
        for key in "${!ENTRY_CACHE[@]}"; do
            debug_log "${key}: ${ENTRY_CACHE[$key]}"
        done
        debug_log "<-= ENTRY_CACHE[@] =->"
    fi
}

main "${@}"
